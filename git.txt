http://djibril.developpez.com/tutoriels/conception/pro-git/
source .git-completion.bash

1. Gestion dan Git
1.1. clone a repository

Le nom du depot est Test :
> git clone https://github.com/YannCobigo/Test.git 

Nous pouvons attribuer un nom arbitrairement MyTest2 :
> git clone https://github.com/YannCobigo/Test.git MyTest2

1.2.1. git status 

Give general information on the local copy of the repository.

1.2.1. git add [file]

Add new file ; index modification for commit

1.2.3. file .gitignore

tell which files to ignore for indexation

1.2.4. git diff

show informations on files differences IF THEY ARE NOT YET INDEXED.
> git diff

show information on files differences IF THEY ARE INDEXED
> git diff --cached/--staged

1.3. git commit

Cette commande lance emacs (git config --global core.editor emacs)
> git commit

On peut direcetment editer le message
> git commit -m "Story 182: Fix benchmarks for speed"

Cette commande permet de mettre tous les fichiers dans la zone d'index, sans avoir a taper la commande 'add'
> git commit -a -m 'added new benchmarks'

Pour eliminer la dernière mise en index. (voir le détail)
> git commit --amend

1.4. git rm

Pour éliminer des fichiers. Il, en premier, enlever le fichier d ela zone de travail
> rm README.md

Puis le retirer de la zone d'index
> git rm README.md

1.5. git log

Donne les information du journal des versions.

Donne des information plus precises: les ligne modifiées
> git log -p

donne le détail des lignes modifiées mais sur deux dernières versions.
> git log -p -2

1.6. git remote -v

Examiner les dépôts a distance.

> git remote show origin

1.6.1. git fetch origin

récupère tout ajout qui a été poussé vers ce dépôt depuis que vous l'avez cloné ou la dernière fois que vous avez récupéré les ajouts. Il faut noter que la commande fetch tire les données dans votre dépôt local mais sous sa propre branche — elle ne les fusionne pas automatiquement avec aucun de vos travaux ni ne modifie votre copie de travail. Vous devez volontairement fusionner ses modifications distantes dans votre travail lorsque vous le souhaitez.

1.6.2. git push [nom-distant] [nom-de-branche]

Lorsque votre dépôt vous semble prêt à être partagé, il faut le pousser en amont.
Cette commande ne fonctionne que si vous avez cloné depuis un serveur sur lequel vous avez des droits d'accès en écriture et si personne n'a poussé dans l'intervalle.

1.6.3. git pull

git va automatiquement fusionner la branche master du dépôt distant après avoir récupéré toutes les références sur le serveur distant.


1.7. git tag

Cette commande donne tous les tag v1.4.2.*
> git tag -l 'v1.4.2.*'

Git utilise deux types principaux de balises : légères et annotées. Une balise légère ressemble beaucoup à une branche qui ne change pas, c'est juste un pointeur sur un commit spécifique. Les balises annotées, par contre sont stockées en tant qu'objets à part entière dans la base de données de Git. Elles ont une somme de contrôle, contiennent le nom et l'adresse e-mail du créateur, la date, un message de balisage et peuvent être signées et vérifiées avec GNU Privacy Guard (GPG). Il est généralement recommandé de créer des balises annotées pour générer toute cette information mais si la balise doit rester temporaire ou l'information supplémentaire n'est pas désirée, il reste toujours les balises légères.

1.7.1. Les balises annotées / TAG

> git tag -a v1.4 -m 'my version 1.4'

Vous pouvez visualiser les données de la balise à côté du commit qui a été marqué en utilisant la commande git show :
> git show v1.4

Par défaut, la commande git push ne transfère pas les balises vers les serveurs distants. Il faut explicitement pousser les balises après les avoir créées localement. Ce processus s'apparente à pousser des branches distantes - vous pouvez lancer git push origin [nom-du-tag].
> git push origin v1.5

Si vous avez de nombreuses balises que vous souhaitez pousser en une fois, vous pouvez aussi utiliser l'option --tags avec la commande git push. Ceci transférera toutes les nouvelles balises vers le serveur distant.
> git push origin --tags

2. Branches

Il faut bien combrandre que les versions des fichiers sont des instantanes du projet. Chaque version sont pointees. Le pointer et la fonction de hachage (SHA-1) sont sauves dans une maille d'une liste chainee. C'est elle qui gere le versionnage.
Si nous n'avons qu'une branche (master) le pointer HEAD represente la tete de l'arbre.
Creation d'une branche testing:
> git branch testing

Git va creer un nouveau pointer "testing" sur le dernier commit testing. La commande suivant va placer le pointeur HEAD sur le nouveau pointer de la branche.
> git checkout testing

Les prochain commit ajouteront des mailles a la chaine pointee par la branche "testing"
> git commit -a -m 'petite modification'

rafaire des travaux dans la branche principale se fait tout simplement par :
> git checkout master
> git commit -a -m 'autres modifications'

2.1. Brancher et fusionner

Suivons un exemple simple de branche et fusion dans une utilisation que vous feriez dans le monde réel. Vous feriez les étapes suivantes :

  -  Travailler sur un site web
  -  Créer une branche pour une nouvelle Story sur laquelle vous souhaiteriez travailler
  -  Réaliser quelques tâches sur cette branche

À cette étape, vous recevez un appel pour vous dire qu'un problème critique a été découvert et qu'il faut le régler au plus tôt. Vous feriez ce qui suit :

  - Revenir à la branche de production
  -  Créer une branche et y développer le correctif
  -  Après un test, fusionner la branche de correctif et pousser le résultat à la production
  -  Rebasculer à la branche initiale et continuer le travail

2.1.1. Creer une branche correctif

Pour gerer le bug 53:
> git branch prob53
> git checkout prob53 

ou, deux commandes en une, creation et switch direct sur la branche prob53:
> git checkout -b prob53
> git commit -a -m 'ajout d'un pied de page [problème 53 fiexed]'

Maintenant vous recevez un appel qui vous apprend qu'il y a un problème sur le site web, un problème qu'il faut résoudre immédiatement. Tout ce que vous avez à faire, c'est simplement rebasculer sur la branche master.
Pour l'instant, vous avez validé tous vos changements dans la branche prob53 et vous pouvez donc rebasculer vers la branche master :
> git checkout master
Switched to branch "master"

À présent, votre répertoire de copie de travail est exactement dans l'état précédent les modifications pour le problème #53 et vous pouvez vous consacrer à votre correctif.
C'est un point important : Git réinitialise le répertoire de travail pour qu'il ressemble à l'instantané de la validation sur laquelle la branche que vous extrayez pointe. Il ajoute, retire et modifie les fichiers automatiquement pour assurer que la copie de travail soit identique à ce qu'elle était lors de votre dernière validation sur la branche.
Ensuite, vous avez un correctif à faire. Créons une branche de correctif sur laquelle travailler jusqu'à ce que ce soit terminé (voir figure 3-13) :
> git checkout -b 'correctif'
Switched to a new branch "correctif"
> git commit -a -m "correction d'une adresse mail incorrecte"
[correctif]: created 3a0874c: "correction d'une adresse mail incorrecte"
 1 files changed, 0 insertions(+), 1 deletions(-)

Vous pouvez lancer vos tests, vous assurer que la correction est efficace et la fusionner dans la branche master pour la déployer en production. Vous réalisez ceci au moyen de la commande git merge :

> git checkout master
> git merge correctif
Updating f42c576..3a0874c
Fast forward
 LISEZMOI |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)

vous allez avant tout effacer la branche correctif parce que vous n'en avez plus besoin et la branche master pointe au même endroit.
> git branch -d correctif
Deleted branch correctif (3a0874c).

Maintenant, il est temps de basculer sur la branche “travaux en cours” sur le problème #53 et de continuer à travailler dessus (voir figure 3-15) :
> git checkout prob53
Switched to branch "prob53"
> git commit -a -m 'Nouveau pied de page terminé [problème 53]'
[prob53]: created ad82d7a: "Nouveau pied de page terminé [problème 53]"
 1 files changed, 1 insertions(+), 0 deletions(-)

Supposons que vous ayez décidé que le travail sur le problème #53 est terminé et se trouve donc prêt à être fusionné dans la branche master.
> git checkout master
> git merge prob53
Merge made by recursive.
 README |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

A présent que votre travail a été fusionné, vous n'avez plus besoin de la branche prob53.
> git branch -d prob53

2.1.2. Conflit de fusion

Si votre résolution du problème #53 a modifié la même section de fichier que le correctif, vous obtiendrez une conflit de fusion qui ressemble à ceci :
> git merge prob53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

Lancez git status pour voir le conflit de fusion. Quels fichiers n'ont pas été fusionnés : 
> git status
index.html: needs merge
# On branch master
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       unmerged:   index.html

Git ajoute des marques de conflit standard dans les fichiers qui comportent des conflits. Votre fichier contient des sections qui ressemblent à ceci :
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
  please contact us at support@github.com
</div>
>>>>>>> prob53:index.html

Après avoir résolu chacune de ces sections dans chaque fichier comportant un conflit, lancez "git add" sur chaque fichier pour le marquer comme résolu.
Vous pouvez lancer à nouveau la commande git status pour vérifier que tous les conflits ont été résolus :
> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   index.html
#

Taper la commande "git commit" pour finaliser le commit de fusion. 
> git commit
Merge branch 'prob53'
Conflicts:
  index.html
#
# It looks like you may be committing a MERGE.
# If this is not correct, please remove the file
# .git/MERGE_HEAD
# and try again.
#















